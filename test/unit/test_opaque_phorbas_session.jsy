import @{} opaque_phorbas
#IF PLAT_WEB
  from '@phorbas/opaque/esm/web/index.mjs'
#ELIF PLAT_NODEJS
  from '@phorbas/opaque/esm/node/index.mjs'

import {cbor_encode, cbor_decode} from 'cbor-codec'
import {utf8_to_u8, u8_to_hex, hex_to_u8} from 'u8-utils'
const { assert, expect } = require('chai')


describe @ 'opaque phorbas session', @::
  opaque_phorbas.init_codec @:
    encode: cbor_encode
    decode: cbor_decode


  const opaque_session = opaque_phorbas.as_session()
  const u8_test_content = utf8_to_u8 @ 'some sample unit test content'
  const kv_test = @{}
    k1ref: hex_to_u8 @ 'a71b96d5a8469be197a85ed8b4a845814f6701777cba27418b3715729316abe2'
    k2loc: hex_to_u8 @ 'defb43abee64e34e3f627c9c105856a9fa75f6b40e561d8f1ce9bab913c12e48'
    value: hex_to_u8 @ '82588401a3804bfa9349eed93bb5f2b11cce14710c84115db85fdfc0b3528bfd41a21dbcf823998e20b9a2799f7e1ea996ddefa20137a90b4cbf6900bb47e1d80fab21dec300f1a752119e3b0f5e4914bd3f01a51256fa53e2e4f79dda8f014f75088916055ceace22a84700dc214766427576c1e297dd0d8dcc0520a591ea32baf367c567933b59010384589e30819b301006072a8648ce3d020106052b81040023038186000400c4295c8f70f8fa37b45fb9f5218360b8039ac6be71f8ba57928bf28e012598d2f1401c41ba3fc62fa2b91fd9fa83fdfbd66c288e0b865ca9967903cbcb2365c9a3018f9bcbc47e5c6d47443f61207c2322c503ca93f2dd99a01d4e2287b71f76247887ba32daf66674106fe70d30bea7c2d574f33a11c35ac6f4c8979c4115b88fec185820defb43abee64e34e3f627c9c105856a9fa75f6b40e561d8f1ce9bab913c12e485064fff292a0432b7f076c22f6f7b11f7c582d04d02ca7c1c48d44aca6bc4fc4a81c647d7fd9ae12c1b4d4a5d3cb6925feae4f25e8f7aa73cd143da2107f24ec'


  it @ 'two from_random', @::>
    const okey_a = await opaque_session.from_random()
    const okey_b = await opaque_session.from_random()

    expect @ okey_a.ec
    .to.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.not.deep.equal @ okey_b.k1ref


  it @ 'two from_content', @::>
    const okey_a = await opaque_session.from_content @ u8_test_content
    const okey_b = await opaque_session.from_content @ u8_test_content

    expect @ okey_a.ec
    .to.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.deep.equal @ okey_b.k1ref

    expect @ okey_a.k2loc
    .to.deep.equal @ okey_b.k2loc


    // ecdsa algorithm uses an ephemeral nonce
    const a_rec = await okey_a.encipher(u8_test_content)
    const a2_rec = await okey_a.encipher(u8_test_content)
    expect(a_rec).to.not.deep.equal(a2_rec)

    const b_rec = await okey_b.encipher(u8_test_content)
    expect(b_rec).to.not.deep.equal(a_rec)


  it @ 'from_random', @::>
    const okey = await opaque_session.from_random()
    const p_rec = okey.encipher(u8_test_content)
    expect(p_rec).to.be.a('promise')

    const rec = await p_rec
    expect(rec).to.be.an.instanceof(Uint8Array)

    const p_check = okey.validate(rec)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(rec)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content


  it @ 'from_k1ref', @::>
    const okey = await opaque_session.from_k1ref(kv_test.k1ref)

    const p_check = okey.validate(kv_test.value)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(kv_test.value)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content

  it @ 'from_k2ref', @::>
    const okey = await opaque_session.from_k2loc(kv_test.k2loc)

    const p_check = okey.validate(kv_test.value)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(kv_test.value)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans
    expect(ans).to.be.undefined


  it @ 'from_k1ref invalid', @::>
    const okey = await opaque_session.from_k1ref(kv_test.k1ref)

    expect @ await okey.decipher(kv_test.value)
    .to.be.deep.equal @ u8_test_content

    for const slice_args of [ [15,-15], [0,-15], [15], ] ::
      const part = kv_test.value.slice @ ...slice_args
      expect @ await okey.decipher(part)
      .to.be.undefined


  it @ 'from_k2ref invalid', @::>
    const okey = await opaque_session.from_k2loc(kv_test.k2loc)

    expect @ await okey.validate(kv_test.value)
    .to.be.true

    for const slice_args of [ [15,-15], [0,-15], [15], ] ::
      const part = kv_test.value.slice @ ...slice_args
      expect @ await okey.validate(part)
      .to.be.false

