import @{} opaque_phorbas
#IF PLAT_WEB
  from '@phorbas/opaque/esm/web/index.mjs'
#ELIF PLAT_NODEJS
  from '@phorbas/opaque/esm/node/index.mjs'

import {cbor_encode, cbor_decode} from 'cbor-codec'
import { utf8_to_u8, u8_to_hex, hex_to_u8 } from 'u8-utils'
const { assert, expect } = require('chai')


describe @ 'opaque phorbas', @::
  const opaque_session = opaque_phorbas.as_session()
  const u8_test_content = utf8_to_u8 @ 'some sample unit test content'
  const kv_test = @{}
    k1ref: hex_to_u8 @ 'df5fc1518264e938ad40aee968494351641480cd22adff6e5063d52d22098fc0'
    k2loc: hex_to_u8 @ 'dc4dad30007a2d713b91e11e5b8c40f78adceeb8b14a8b23951e452a3ba7a040'
    value: hex_to_u8 @ '8258840045adbcfc95f1fbcff545ddd28dc4cd1db2f1f4a411faa32915b784dbb5d0b317b60e90eec648fec2b92b4e844046a848b153960a3f45503b2ea97980115fb9450301f663f7a7437260c59eaa16599f3bd6bcf62a3d1fe7e6de8f9ef0563c467dde528d4ce978d99a8bd96643ecaad66512350fc16a071152a29d9c55bb0664f3e464ed58f283589e30819b301006072a8648ce3d020106052b81040023038186000401281921ba4dd0c7be819bb528f05853eb68e5f94720e6cc5592cbfabb037c3e779dc51b54516ae6756379899ea629dbbd9c4acc717d4e06885af96d301883d3ea33011db54b0ca66864ce1e08d44bcb79289e69f8d77835fe28ba08f76f72751f93d8eabec24423c1eb4ea30e6ea50adb360fb12c7c5ae17331c7c70ce6c5c476a7c0be5820dc4dad30007a2d713b91e11e5b8c40f78adceeb8b14a8b23951e452a3ba7a040582d4e3dc0b0e516752c64922e622728adea8cfa680b5e17588ebcf9f4abeb1d8aafaa6eafc4ab2aa1873075022102'


  it @ 'two from_random', @::>
    const okey_a = await opaque_session.from_random()
    const okey_b = await opaque_session.from_random()

    expect @ okey_a.ec
    .to.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.not.deep.equal @ okey_b.k1ref


  it @ 'two from_content', @::>
    const okey_a = await opaque_session.from_content @ u8_test_content
    const okey_b = await opaque_session.from_content @ u8_test_content

    expect @ okey_a.ec
    .to.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.deep.equal @ okey_b.k1ref

    expect @ okey_a.k2loc
    .to.deep.equal @ okey_b.k2loc


    // ecdsa algorithm uses an ephemeral nonce
    const a_rec = await okey_a.encipher(u8_test_content)
    const a2_rec = await okey_a.encipher(u8_test_content)
    expect(a_rec).to.not.deep.equal(a2_rec)

    const b_rec = await okey_b.encipher(u8_test_content)
    expect(b_rec).to.not.deep.equal(a_rec)


  it @ 'from_random', @::>
    const okey = await opaque_session.from_random()
    const p_rec = okey.encipher(u8_test_content)
    expect(p_rec).to.be.a('promise')

    const rec = await p_rec
    expect(rec).to.be.an.instanceof(Uint8Array)

    const p_check = okey.validate(rec)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(rec)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content


  it @ 'from_k1ref', @::>
    const okey = await opaque_session.from_k1ref(kv_test.k1ref)

    const p_check = okey.validate(kv_test.value)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(kv_test.value)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content

  it @ 'from_k2ref', @::>
    const okey = await opaque_session.from_k2loc(kv_test.k2loc)

    const p_check = okey.validate(kv_test.value)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(kv_test.value)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans
    expect(ans).to.be.undefined


  it @ 'from_k1ref invalid', @::>
    const okey = await opaque_session.from_k1ref(kv_test.k1ref)

    expect @ await okey.decipher(kv_test.value)
    .to.be.deep.equal @ u8_test_content

    for const slice_args of [ [15,-15], [0,-15], [15], ] ::
      const part = kv_test.value.slice @ ...slice_args
      expect @ await okey.decipher(part)
      .to.be.undefined


  it @ 'from_k2ref invalid', @::>
    const okey = await opaque_session.from_k2loc(kv_test.k2loc)

    expect @ await okey.validate(kv_test.value)
    .to.be.true

    for const slice_args of [ [15,-15], [0,-15], [15], ] ::
      const part = kv_test.value.slice @ ...slice_args
      expect @ await okey.validate(part)
      .to.be.false

