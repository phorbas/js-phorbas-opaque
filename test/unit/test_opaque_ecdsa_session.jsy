import @{} opaque_ecdsa
#IF PLAT_WEB
  from '@phorbas/opaque/esm/web/index.mjs'
#ELIF PLAT_NODEJS
  from '@phorbas/opaque/esm/node/index.mjs'

import @{}
  cbor_encode, cbor_decode,
  utf8_to_u8, u8_to_hex, hex_to_u8,
from 'cbor-codec'
const { assert, expect } = require('chai')


describe @ 'opaque ecdsa session', @::
  opaque_ecdsa.init_shared_codec @:
    encode: cbor_encode
    decode: cbor_decode


  const opaque_session = opaque_ecdsa.as_session()
  const u8_test_content = utf8_to_u8 @ 'some sample unit test content'
  const kv_test = @{}
    k1ref: hex_to_u8 @ '548745e06b24c9680bbd2abff061663e34ce096d900940688d9472ac7b286433'
    k2loc: hex_to_u8 @ '233e65e0182935686f8cb8bf119bff3e79e6d06dd1e2b7685a3174acb620ac33'
    value: hex_to_u8 @ 'a2617a588401c17b8b1c60d2db37c746d41a3c104cb60b2a8f089d2924ba0bd03039a4c4bfde77c1d705c3ffc93962868fdbdd8685e54a144291a9a2c90f95e874dad667180f8a00909dc4e1d10d447cbd61d0d4855393957759d56c965a98a6a097b55faa2adbdd2917ac4e64cdb5ea7f1da4d4c9a944a325ef05327fbee59b6c8e0af226c468cb83616259010ba46163582d7f73213bacba6d0cb883366435def02fab7e6a5f2b83cd6f6fad09a36e9c4f08629b73c9f0aff89eca58a44a17617650c023040336f23cc8e8d247d60ed392cb616c5820233e65e0182935686f8cb8bf119bff3e79e6d06dd1e2b7685a3174acb620ac336165589e30819b301006072a8648ce3d020106052b81040023038186000400567b5066036d26c269ffd68329e36f7a340a135e32c1110f981855518ff41acf4d48304a6bdbbd31682235c36bd9a7c5b754e9f2f3352c92ebf57ed497edae033f00e674fb514f972043761faa9b8087eae901f9f3d635effa5a8d9e0d04d659a79a4b4c3bb49142199e08dc8f4834b41d762be5bf66bb329a04f75c6f05f1ee3fcf3f'

  if 0 ::
    return it.only @ 'REGEN kv_test data', @::>
      const okey = await opaque_session.from_random()
      const rec = await okey.encipher(u8_test_content)

      console.log @ `
          const kv_test = @{}
            k1ref: hex_to_u8 @ '${u8_to_hex @ okey.k1ref}'
            k2loc: hex_to_u8 @ '${u8_to_hex @ okey.k2loc}'
            value: hex_to_u8 @ '${u8_to_hex @ rec}'
        `


  it @ 'two from_random', @::>
    const okey_a = await opaque_session.from_random()
    const okey_b = await opaque_session.from_random()

    expect @ okey_a.ec
    .to.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.not.deep.equal @ okey_b.k1ref


  it @ 'two from_content', @::>
    const okey_a = await opaque_session.from_content @ u8_test_content
    const okey_b = await opaque_session.from_content @ u8_test_content

    expect @ okey_a.ec
    .to.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.deep.equal @ okey_b.k1ref

    expect @ okey_a.k2loc
    .to.deep.equal @ okey_b.k2loc


    // ecdsa algorithm uses an ephemeral nonce
    const a_rec = await okey_a.encipher(u8_test_content)
    const a2_rec = await okey_a.encipher(u8_test_content)
    expect(a_rec).to.not.deep.equal(a2_rec)

    const b_rec = await okey_b.encipher(u8_test_content)
    expect(b_rec).to.not.deep.equal(a_rec)


  it @ 'from_random', @::>
    const okey = await opaque_session.from_random()
    const p_rec = okey.encipher(u8_test_content)
    expect(p_rec).to.be.a('promise')

    const rec = await p_rec
    expect(rec).to.be.an.instanceof(Uint8Array)

    const p_check = okey.validate(rec)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(rec)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content


  describe @ 'known', @::
    it @ 'from_k1ref', @::>
      const okey = await opaque_session.from_k1ref(kv_test.k1ref)

      const p_check = okey.validate(kv_test.value)
      expect(p_check).to.be.a('promise')
      const check = await p_check
      expect(check).to.be.true

      const p_ans = okey.decipher(kv_test.value)
      expect(p_ans).to.be.a('promise')
      const ans = await p_ans

      expect(ans).to.be.an.instanceof(Uint8Array)
      expect(ans).to.be.deep.equal @ u8_test_content

    it @ 'from_k2ref', @::>
      const okey = await opaque_session.from_k2loc(kv_test.k2loc)

      const p_check = okey.validate(kv_test.value)
      expect(p_check).to.be.a('promise')
      const check = await p_check
      expect(check).to.be.true

      const p_ans = okey.decipher(kv_test.value)
      expect(p_ans).to.be.a('promise')
      const ans = await p_ans
      expect(ans).to.be.undefined


    it @ 'from_k1ref invalid', @::>
      const okey = await opaque_session.from_k1ref(kv_test.k1ref)

      expect @ await okey.decipher(kv_test.value)
      .to.be.deep.equal @ u8_test_content

      for const slice_args of [ [15,-15], [0,-15], [15], ] ::
        const part = kv_test.value.slice @ ...slice_args
        expect @ await okey.decipher(part)
        .to.be.undefined


    it @ 'from_k2ref invalid', @::>
      const okey = await opaque_session.from_k2loc(kv_test.k2loc)

      expect @ await okey.validate(kv_test.value)
      .to.be.true

      for const slice_args of [ [15,-15], [0,-15], [15], ] ::
        const part = kv_test.value.slice @ ...slice_args
        expect @ await okey.validate(part)
        .to.be.false

