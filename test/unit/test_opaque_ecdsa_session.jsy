import @{} opaque_ecdsa
#IF PLAT_WEB
  from '@phorbas/opaque/esm/web/index.mjs'
#ELIF PLAT_NODEJS
  from '@phorbas/opaque/esm/node/index.mjs'

import @{}
  cbor_encode, cbor_decode,
  utf8_to_u8, u8_to_hex, hex_to_u8,
from 'cbor-codec'
const { assert, expect } = require('chai')


describe @ 'opaque ecdsa session', @::
  opaque_ecdsa.init_shared_codec @:
    encode: cbor_encode
    decode: cbor_decode


  const opaque_session = opaque_ecdsa.as_session()
  const u8_test_content = utf8_to_u8 @ 'some sample unit test content'
  const kv_test = @{}
    k1ref: hex_to_u8 @ 'c9a74a81a4fc84184cf1de31bb03c3388c352aa7a597872beee4a521d6f9f6ef'
    k2loc: hex_to_u8 @ '05d5adda876dc68ca5ee4b5c4814b787e03c683886d073559317a521d6f9f6ef'
    value: hex_to_u8 @ 'a2617a588401e68fb6a6a7f40954584a9e76bd16f452d29700635e2411e4d1e8e80855af6004aac7d1a0c498fb6b7c7c4f3ea72774708f2f585519d7e4fceb999a389b15a6ecad01e3cf9803ae5d94dce03cd795eaf965f7a829b0db51f1f7a9980ef594494e0874d935a1c394c7b5476ec0d31ecc637947c2022537ebe55fc750adcd34ea626e30f9616259010ba46163582d614f57d5af0fee17dcb99993d5f44fe661df4fdf87c2150a0fa8b020c63aa3d2679ab3a865d97ea7353603b675617650f18274a06122438d4553b6d63bd92517616c582005d5adda876dc68ca5ee4b5c4814b787e03c683886d073559317a521d6f9f6ef6165589e30819b301006072a8648ce3d020106052b810400230381860004002f36d0fe44daea86ac583cbab454e6dadbebd12e3afc54ee0eb0e11611f42925b87e36fe021ac1129a945f9e4979dfb45babf6c3674dbc30b1cd3d4ada88466c26000dd5f4f38d569fe8594dbdbb004087d489350847b4a6a4761b0b56b359adbcea0614ca71a31c7f17fc44ac25997b472cb265236d0beac4bd0e57c924841571069e'

  if 0 ::
    return it.only @ 'REGEN kv_test data', @::>
      const okey = await opaque_session.from_random()
      const rec = await okey.encipher(u8_test_content)

      console.log @ `
        const kv_test = @{}
          k1ref: hex_to_u8 @ '${u8_to_hex @ okey.k1ref}'
          k2loc: hex_to_u8 @ '${u8_to_hex @ okey.k2loc}'
          value: hex_to_u8 @ '${u8_to_hex @ rec}'
        `


  it @ 'two from_random', @::>
    const okey_a = await opaque_session.from_random()
    const okey_b = await opaque_session.from_random()

    expect @ okey_a.ec
    .to.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.not.deep.equal @ okey_b.k1ref


  it @ 'two from_content', @::>
    const okey_a = await opaque_session.from_content @ u8_test_content
    const okey_b = await opaque_session.from_content @ u8_test_content

    expect @ okey_a.ec
    .to.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.deep.equal @ okey_b.k1ref

    expect @ okey_a.k2loc
    .to.deep.equal @ okey_b.k2loc


    // ecdsa algorithm uses an ephemeral nonce
    const a_rec = await okey_a.encipher(u8_test_content)
    const a2_rec = await okey_a.encipher(u8_test_content)
    expect(a_rec).to.not.deep.equal(a2_rec)

    const b_rec = await okey_b.encipher(u8_test_content)
    expect(b_rec).to.not.deep.equal(a_rec)


  it @ 'from_random', @::>
    const okey = await opaque_session.from_random()
    const p_rec = okey.encipher(u8_test_content)
    expect(p_rec).to.be.a('promise')

    const rec = await p_rec
    expect(rec).to.be.an.instanceof(Uint8Array)

    const p_check = okey.validate(rec)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(rec)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content


  it @ 'from_k1ref', @::>
    const okey = await opaque_session.from_k1ref(kv_test.k1ref)

    const p_check = okey.validate(kv_test.value)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(kv_test.value)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content

  it @ 'from_k2ref', @::>
    const okey = await opaque_session.from_k2loc(kv_test.k2loc)

    const p_check = okey.validate(kv_test.value)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(kv_test.value)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans
    expect(ans).to.be.undefined


  it @ 'from_k1ref invalid', @::>
    const okey = await opaque_session.from_k1ref(kv_test.k1ref)

    expect @ await okey.decipher(kv_test.value)
    .to.be.deep.equal @ u8_test_content

    for const slice_args of [ [15,-15], [0,-15], [15], ] ::
      const part = kv_test.value.slice @ ...slice_args
      expect @ await okey.decipher(part)
      .to.be.undefined


  it @ 'from_k2ref invalid', @::>
    const okey = await opaque_session.from_k2loc(kv_test.k2loc)

    expect @ await okey.validate(kv_test.value)
    .to.be.true

    for const slice_args of [ [15,-15], [0,-15], [15], ] ::
      const part = kv_test.value.slice @ ...slice_args
      expect @ await okey.validate(part)
      .to.be.false

