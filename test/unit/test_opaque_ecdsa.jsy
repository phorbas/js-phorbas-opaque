import @{} opaque_ecdsa
#IF PLAT_WEB
  from '@phorbas/opaque/esm/web/index.mjs'
#ELIF PLAT_NODEJS
  from '@phorbas/opaque/esm/node/index.mjs'

import @{}
  cbor_encode, cbor_decode,
  utf8_to_u8, u8_to_hex, hex_to_u8,
from 'cbor-codec'

const { assert, expect } = require('chai')

describe @ 'opaque ecdsa', @::
  opaque_ecdsa.init_shared_codec @:
    encode: cbor_encode
    decode: cbor_decode


  const u8_test_content = utf8_to_u8 @ 'some sample unit test content'
  const kv_test = @{}
    k1ref: hex_to_u8 @ '49c93493adf4d235a356bb88d56ce1ff8f6c38b0bc65cb09c16d5e5b8b6cecb8'
    k2loc: hex_to_u8 @ '9eee639362bb3235ff53668833a93bff8235b8b0888a26098e42265b7e934db8'
    value: hex_to_u8 @ 'a2617a58840056482fcb02c0fc0a0fa50b78ad95c9a8f944c9507286d12a50406ce774e6cccd90c1ae1870bde49192a28ed965123744db07481fb92c87774b62d0c1cfc184304a01e10931a23ed6d8ff5a2be521fb08887e88a79c47d04daf6e54d7b3b03237afa68aa6d6956a398fff0d47210e21e1054bfda2de713c06c82dcc04bbad129bacbae8616259010ba46163582d2559a73a72cece73cfde3c5a465bbe70d336e07634fc5681a8296c2a8dce89f0b0b6e94743315f1363a6b2f1c96176505ba5c3b33f8b593c4cbe62511617b858616c58209eee639362bb3235ff53668833a93bff8235b8b0888a26098e42265b7e934db86165589e30819b301006072a8648ce3d020106052b81040023038186000401ebf0f9df0271068122c75a4904d2956a7e54e8897f524e0ff3b69d33aea34e96fbcd8d8eb075f254faade241a4bb91274b24e4f0670df735bc50969043f1ea347601c7d410dd0a8fab8469cebc96c5c031d1d1a75b6c54255a13ef353a023fa722e793a06661ac2c0ec93cdc8afef0c7edc13dc9360ecd1ad52d7dbb93490a3f2eb67e'

  if 0 ::
    return it.only @ 'REGEN kv_test data', @::>
      const okey = await opaque_ecdsa.from_random()
      const rec = await okey.encipher(u8_test_content)

      console.log @ `
        const kv_test = @{}
          k1ref: hex_to_u8 @ '${u8_to_hex @ okey.k1ref}'
          k2loc: hex_to_u8 @ '${u8_to_hex @ okey.k2loc}'
          value: hex_to_u8 @ '${u8_to_hex @ rec}'
        `


  it @ 'two from_random', @::>
    const okey_a = await opaque_ecdsa.from_random()
    const okey_b = await opaque_ecdsa.from_random()

    expect @ okey_a.ec
    .to.not.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.not.deep.equal @ okey_b.k1ref


  it @ 'two from_content', @::>
    const okey_a = await opaque_ecdsa.from_content @ u8_test_content
    const okey_b = await opaque_ecdsa.from_content @ u8_test_content

    expect @ okey_a.ec
    .to.not.deep.equal @ okey_b.ec

    expect @ okey_a.k1ref
    .to.not.deep.equal @ okey_b.k1ref

    expect @ okey_a.k2loc
    .to.not.deep.equal @ okey_b.k2loc


  it @ 'from_random', @::>
    const okey = await opaque_ecdsa.from_random()
    const p_rec = okey.encipher(u8_test_content)
    expect(p_rec).to.be.a('promise')

    const rec = await p_rec
    expect(rec).to.be.an.instanceof(Uint8Array)

    const p_check = okey.validate(rec)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(rec)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content

  it @ 'from_k1ref', @::>
    const okey = await opaque_ecdsa.from_k1ref(kv_test.k1ref)

    const p_check = okey.validate(kv_test.value)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(kv_test.value)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans

    expect(ans).to.be.an.instanceof(Uint8Array)
    expect(ans).to.be.deep.equal @ u8_test_content


  it @ 'from_k2ref', @::>
    const okey = await opaque_ecdsa.from_k2loc(kv_test.k2loc)

    const p_check = okey.validate(kv_test.value)
    expect(p_check).to.be.a('promise')
    const check = await p_check
    expect(check).to.be.true

    const p_ans = okey.decipher(kv_test.value)
    expect(p_ans).to.be.a('promise')
    const ans = await p_ans
    expect(ans).to.be.undefined


  it @ 'from_k1ref invalid', @::>
    const okey = await opaque_ecdsa.from_k1ref(kv_test.k1ref)

    expect @ await okey.decipher(kv_test.value)
    .to.be.deep.equal @ u8_test_content

    for const slice_args of [ [15,-15], [0,-15], [15], ] ::
      const part = kv_test.value.slice @ ...slice_args
      expect @ await okey.decipher(part)
      .to.be.undefined


  it @ 'from_k2ref invalid', @::>
    const okey = await opaque_ecdsa.from_k2loc(kv_test.k2loc)

    expect @ await okey.validate(kv_test.value)
    .to.be.true

    for const slice_args of [ [15,-15], [0,-15], [15], ] ::
      const part = kv_test.value.slice @ ...slice_args
      expect @ await okey.validate(part)
      .to.be.false

