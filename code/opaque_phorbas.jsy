import {cbor_encode, cbor_decode} from 'cbor-codec'
import {opaque_basic_api} from './opaque_basic.jsy'
import @{}
  u8_aes_256_gcm
  u8_hmac_sha_256
  u8_ecdsa_p521_256
  u8_fast_equal
  u8_typecheck
from './subtle.jsy'


export const opaque_phorbas_api = @{}
  ... opaque_basic_api

  _hmac: u8_hmac_sha_256
  key_proto: @{}
    ... bind_opaque_phorbas @
          u8_ecdsa_p521_256, u8_aes_256_gcm


export const opaque_phorbas = @{} __proto__: @{}
  ... opaque_phorbas_api

  _kdf1_ref(u8_k0, kctx) ::
    return this._hmac(kctx.ec).sign(u8_k0)

  async _init_key(is_new) ::
    const kctx = @{} __proto__: this.key_proto
    await kctx._init_eckey(is_new, kctx)
    return kctx

  as_session() ::
    return @{} __proto__: this,
      key_proto: this.key_proto.as_session()



export function bind_opaque_phorbas(ecdsa, cipher) ::
  return @{}
    async _init_eckey(is_new, kctx) ::
      const ec_sign = ecdsa.sign()
      kctx._ec_sign = ec_sign
      kctx.ec = await ec_sign.ec
      return kctx

    as_session() ::
      const ec_sign = ecdsa.sign()

      return @{} __proto__: this,
        as_session() :: return this
        async _init_eckey(is_new, kctx) ::
          kctx._ec_sign = ec_sign
          kctx.ec = await ec_sign.ec
          return kctx


    async encipher(u8_content) ::
      const {k1ref, k2loc} = this
      const u8_enc = await cipher.encrypt @
        u8_content, k1ref, k2loc

      return await this.pack_opaque @
        u8_enc, k1ref, k2loc


    async decipher(rec_cbor) ::
      const {k1ref, k2loc} = this
      if undefined === k1ref || undefined === k2loc ::
        return

      const u8_enc = await this._unpack_opaque(rec_cbor)
      if undefined === u8_enc ::
        return

      return await cipher.decrypt @
        u8_enc, k1ref, k2loc


    async validate(rec_cbor) ::
      const u8_enc = await this._unpack_opaque(rec_cbor)
      return u8_enc instanceof Uint8Array


    async _unpack_opaque(rec_cbor) ::
      let sig, body, ec, _k2loc, u8_enc
      try ::
        ;[sig, body] = u8_typecheck @ cbor_decode(rec_cbor)
        ;[ec, _k2loc, u8_enc] = u8_typecheck @ cbor_decode(body)
      catch err ::
        return // ignore cbor decoding error

      if u8_fast_equal @ this.k2loc, _k2loc ::
        if await ecdsa.verify @ {ec, sig}, body ::
          return u8_enc


    async pack_opaque(u8_enc, k1ref, k2loc) ::
      const {_ec_sign} = this
      const body = cbor_encode @#
        await _ec_sign.ec, k2loc, u8_enc
      const {sig} = await _ec_sign(body)
      return cbor_encode @#
        sig, body

