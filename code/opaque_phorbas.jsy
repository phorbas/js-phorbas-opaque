import {opaque_basic_api} from './opaque_basic.jsy'
import {bind_tahoe_cipher} from './opaque_tahoe.jsy'

import @{}
  u8_aes_256_gcm
  u8_hmac_sha_256
  u8_ecdsa_p521_256
  u8_fast_equal
  u8_typecheck
from './subtle.jsy'


export const opaque_phorbas_api = @{}
  ... opaque_basic_api

  _hmac: u8_hmac_sha_256
  key_proto: @{}
    ... bind_phorbas @:
          ecdsa: u8_ecdsa_p521_256
          cipher: u8_aes_256_gcm


export const opaque_phorbas = @{}
  ... opaque_phorbas_api

  _kdf1_ref(u8_k0, kctx) ::
    return this._hmac(kctx.ec).sign(u8_k0)

  async _init_key(is_new) ::
    const kctx = @{} __proto__: this.key_proto
    await kctx._init_eckey(is_new, kctx)
    return kctx

  as_session(...args) ::
    return @{} __proto__: this,
      as_session: null
      key_proto: this.key_proto.as_session(...args)


export const phorbas = @=> opaque_phorbas



export function bind_phorbas({ecdsa, cipher}) ::
  return @{}
    ... bind_tahoe_cipher(cipher)
    ... bind_ecdsa_codec(ecdsa)

    async validate(record) ::
      if record ::
        const res = await this._unpack_opaque(record)
        return undefined !== res


export function bind_ecdsa_codec(ecdsa) ::
  return @{}

    async _pack_opaque(obj_body) ::
      const {_ec_sign, _codec} = this

      obj_body.e = await _ec_sign.ec
      const body = _codec.encode(obj_body)
      const {sig} = await _ec_sign(body)

      return _codec.encode @: z:sig, b:body


    async _unpack_opaque(record) ::
      const {decode} = this._codec
      let obj_sig
      try :: obj_sig = decode(record)
      catch err :: return // ignore decoding error

      const {z:sig, b:body} = obj_sig

      let obj_body
      try :: obj_body = decode(body)
      catch err :: return // ignore decoding error

      const {e: ec, l: _k2loc} = obj_body
      if u8_fast_equal @ this.k2loc, _k2loc ::
        try ::
          if await ecdsa.verify @ {ec, sig}, body ::
            return obj_body
        catch err :: return // ignore verify errors


    async _init_eckey(is_new, kctx) ::
      const ec_sign = ecdsa.sign()
      kctx._ec_sign = ec_sign
      kctx.ec = await ec_sign.ec
      return kctx

    as_session(ec_sign) ::
      if ! ec_sign ::
        ec_sign = ecdsa.sign()

      return @{} __proto__: this,
        as_session: null
        async _init_eckey(is_new, kctx) ::
          kctx._ec_sign = ec_sign
          kctx.ec = await ec_sign.ec
          return kctx

