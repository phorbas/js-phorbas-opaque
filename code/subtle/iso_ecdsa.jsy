#IF PLAT_ABSTRACT
  export function _bind_ecdsa(hash) ::
    return @{}
      signer_p521()
      signer_p384()
      signer_p256()
      async verify(ec_sig_obj, u8) ::


#ELIF PLAT_WEB
  export function _bind_ecdsa(hash) ::
    const {subtle} = crypto
    return @{}
      signer_p521: @=> _ecdsa_signer @ 'P-521'
      signer_p384: @=> _ecdsa_signer @ 'P-384'
      signer_p256: @=> _ecdsa_signer @ 'P-256'
      verify: ecdsa_verify
      hash


    async function ecdsa_verify(ec_sig_obj, u8) ::
      const {ec, sig} = ec_sig_obj, ec_len = ec.length
      const _kind = @{} name: 'ECDSA', hash,
        namedCurve: 158===ec_len ? 'P-521'
          : 120===ec_len ? 'P-384'
          : 91===ec_len ? 'P-256'
          : '?'

      const ec_pub = subtle.importKey @
        'spki', ec, _kind, false, ['verify']

      return subtle.verify @
        _kind, await ec_pub, sig, u8


    function _ecdsa_signer(namedCurve) ::
      const _kind = {name: 'ECDSA', namedCurve, hash}
      const _ec_ = subtle
        .generateKey @ _kind, false, ['sign']
        .then @\ _ec_ ::>
          _ec_.publicKey = new Uint8Array @
            await subtle.exportKey('spki', _ec_.publicKey)
          return _ec_

      return Object.assign @ ecdsa_sign, @{}
        ec: _ec_.then @ _ec_ => _ec_.publicKey
        ecdsa_sign, ecdsa_verify
        hash, namedCurve


      async function ecdsa_sign(u8) ::
        const {publicKey, privateKey} = await _ec_
        const u8_sig = new Uint8Array @
          await subtle.sign @
            _kind, privateKey, u8

        return @{}
          ec: new Uint8Array(publicKey)
          sig: u8_sig



#ELIF PLAT_NODEJS
  import {promisify} from 'util'
  import {generateKeyPair, createPublicKey, createSign, createVerify} from 'crypto'
  import {decode_ecdsa_asn1, encode_ecdsa_asn1, decode_ecdsa_raw, encode_ecdsa_raw} from 'ecc-codec/esm/ecdsa/index.mjs'
  const _generateKeyPair_p = promisify(generateKeyPair)

  export function _bind_ecdsa(hash) ::
    return @{}
      signer_p521: @=> _ecdsa_signer @ 'P-521', 'secp521r1'
      signer_p384: @=> _ecdsa_signer @ 'P-384', 'secp384r1'
      signer_p256: @=> _ecdsa_signer @ 'P-256', 'prime256v1'
      verify: ecdsa_verify
      hash


    async function ecdsa_verify(ec_sig_obj, u8) ::
      const ec_pub = createPublicKey @:
        key: ec_sig_obj.ec, format: 'der', type: 'spki'

      const ver =
        createVerify @ hash.replace('-','')
        .update(u8).end()

      const asn1_sig = encode_ecdsa_asn1 @
        decode_ecdsa_raw(ec_sig_obj.sig)

      return ver.verify @ ec_pub, asn1_sig


    function _ecdsa_signer(namedCurve, namedCurve_node) ::
      const _ec_ = _generateKeyPair_p @ 'ec', @{}
        namedCurve: namedCurve_node
        publicKeyEncoding: @{}
          type: 'spki', format: 'der'

      return Object.assign @ ecdsa_sign, @{}
        ec: _ec_.then @ _ec_ => new Uint8Array @ _ec_.publicKey
        ecdsa_sign, ecdsa_verify
        hash, namedCurve, namedCurve_node


      async function ecdsa_sign(u8) ::
        const {publicKey, privateKey} = await _ec_
        const asn1_sig =
          createSign @ hash.replace('-','')
          .update(u8).end()
          .sign(privateKey)

        const u8_sig = encode_ecdsa_raw @
          decode_ecdsa_asn1(asn1_sig)

        return @{} 
          ec: new Uint8Array(publicKey)
          sig: u8_sig



function _maybe_sign(u8, sign) ::
  return undefined !== u8
    ? sign(u8)
    : sign


export const u8_ecdsa_sha_256 = _bind_ecdsa('SHA-256')
export const u8_ecdsa_sha_384 = _bind_ecdsa('SHA-384')
export const u8_ecdsa_sha_512 = _bind_ecdsa('SHA-512')

export @{}
  u8_ecdsa_sha_256 as u8_ecdsa

