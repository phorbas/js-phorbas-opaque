#IF PLAT_ABSTRACT
  export function _bind_hmac_sha(hash) ::
    return u8_key => @:
      async sign(u8_buf) ::
      async verify(u8_sig, u8_buf) ::


#ELIF PLAT_WEB
  import {utf8_to_u8} from './utils.jsy'

  export function _bind_hmac_sha(hash) ::
    const {subtle} = crypto
    return @\ u8_key ::
      if 'string' === typeof u8_key ::
        u8_key = utf8_to_u8(u8_key)

      const key = subtle.importKey @
        'raw', u8_key, {name: 'HMAC', hash},
        false, ['sign', 'verify']

      return @{}
        async sign(u8_buf) ::
          return new Uint8Array @
            await subtle.sign @
              {name: 'HMAC'}, await key, u8_buf

        async verify(u8_sig, u8_buf) ::
          return subtle.verify @
            {name: 'HMAC'}, await key,
            u8_sig, u8_buf


#ELIF PLAT_NODEJS
  import {createHmac} from 'crypto'
  import {u8_timing_equal} from './utils.jsy'

  export function _bind_hmac_sha(hash) ::
    return u8_key => @:
      async sign(u8_buf) ::
        return _hmac(u8_key, u8_buf)

      async verify(u8_sig, u8_buf) ::
        const u8_actual = _hmac(u8_key, u8_buf)
        return u8_timing_equal @ u8_actual, u8_sig

    function _hmac(u8_key, u8_buf) ::
      return new Uint8Array @
        createHmac(hash.replace('-',''), u8_key)
          .update(u8_buf)
          .digest()


export const u8_hmac_sha_256 = _bind_hmac_sha('SHA-256')
export const u8_hmac_sha_384 = _bind_hmac_sha('SHA-384')
export const u8_hmac_sha_512 = _bind_hmac_sha('SHA-512')

export @{}
  u8_hmac_sha_256 as u8_hmac_sha,
  u8_hmac_sha_256 as u8_hmac,

