import {as_hexkey, hex_to_u8} from './subtle/utils.jsy'
import {opaque_core_api} from './core_api.jsy'
import {okey_basic} from './basic/key_basic.jsy'
import {okey_ciphered} from './key_ciphered.jsy'


const opaque_comp_api = /* #__PURE__ */ Object.freeze @:
  ... opaque_core_api
  //opaque_a: opaque
  //opaque_b: opaque
  //key_proto: okey_basic or okey_kx_a or okey_kx_b

  async _init_key(is_new) ::
    return @{}
      __proto__: this.key_proto
      kx_a: await this.opaque_a._init_key(is_new)
      kx_b: await this.opaque_b._init_key(is_new)

  async _finish_key(kctx) ::
    kctx.kx_a = await this.opaque_a._finish_key(kctx.kx_a)
    kctx.kx_b = await this.opaque_b._finish_key(kctx.kx_b)
    return kctx

  _kdf0_hash(buf) ::
    return this.opaque_a._kdf0_hash(buf)

  _kdf1_ref(u8_k0, kctx) ::
    return this.opaque_a._kdf1_ref(u8_k0, kctx.kx_a)

  async _kdf2_loc(hk1ref, kctx) ::
    let k1mid = await this.opaque_a._kdf2_loc(hk1ref, kctx.kx_a)
    kctx.hk1mid = as_hexkey @ k1mid
    return this.opaque_b._kdf2_loc(k1mid, kctx.kx_b)


const _with_hk21 = (hk1ref, hk2loc, tgt) => @: __proto__: tgt, hk1ref, hk2loc

const okey_kx_a = Object.freeze @:
  __proto__: okey_ciphered
  encipher(...args) ::
    return _with_hk21(this.hk1ref, this.hk2loc, this.kx_a).encipher(...args)
  decipher(...args) ::
    return _with_hk21(this.hk1ref, this.hk2loc, this.kx_a).decipher(...args)

const okey_kx_b = Object.freeze @:
  __proto__: okey_ciphered
  encipher(...args) ::
    return _with_hk21(this.hk1mid, this.hk2loc, this.kx_b).encipher(...args)
  decipher(...args) ::
    return _with_hk21(this.hk1mid, this.hk2loc, this.kx_b).decipher(...args)


export function opaque_compose(opaque_a, opaque_b) ::
  let key_proto = opaque_b.ciphered ? okey_kx_b
    : opaque_a.ciphered ? okey_kx_a
    : okey_basic

  return @{} __proto__: opaque_comp_api, opaque_a, opaque_b
    key_proto, ciphered: key_proto.ciphered

