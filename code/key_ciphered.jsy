import {u8_crypto_random} from './subtle/iso_random.jsy'

export const kdf_random_16 = () => u8_crypto_random(16)

export const okey_ciphered = Object.freeze @:
  hk21() :: return [this.hk2loc, this.hk1ref]
  get 0() :: return this.k2loc
  get 1() :: return this.k1ref
  ciphered: true

  // async encipher(u8_content) ::
  // async decipher(u8_record) ::

  _rec_pack(rec) ::
    return this.codec.encode(rec)
  _rec_unpack(u8_record) ::
    return this.codec.decode(u8_record)


export function bind_okey_ciphered(cipher) ::
  return @{}
    __proto__: okey_ciphered

    _kdf_iv: kdf_random_16
    // _kdf_secret: k1ref => k1ref

    async encipher(u8_content) ::
      const {k1ref, k2loc, _kdf_secret, _kdf_iv} = this
      if k1ref && k2loc ::
        const u8_secret = ! _kdf_secret ? k1ref
          : await _kdf_secret(k1ref)

        const u8_iv = await _kdf_iv(k2loc)

        const u8_enc = await cipher.encrypt @
          u8_content, u8_secret, u8_iv

        return await this._rec_pack @:
          c:u8_enc, v:u8_iv, l:k2loc

    async decipher(u8_record) ::
      const {k1ref, _kdf_secret} = this
      if u8_record && k1ref ::
        const {v:u8_iv, c:u8_enc} =
          await this._rec_unpack(u8_record) || {}

        const u8_secret = ! _kdf_secret ? k1ref
          : await _kdf_secret(k1ref)

        if u8_enc && u8_secret && u8_iv ::
          return await cipher.decrypt @
            u8_enc, u8_secret, u8_iv

